/*
 * Please read the main.c file for license.
 */

#include "parser.h"
#include "lexer.h"
#include "version.h"
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUFFER_SIZE 256
#define FOOTER_MULTIPLIER 8
#define MAX_TOKEN_LENGTH 100
#define MAX_SAFE_VARIABLES 1000

char *nptr = NULL;
char *varStrKeep = "";
char *pVars[MAX_SAFE_VARIABLES];
int pVarsLen = 0;

Token currentToken(Parser *parser) { return parser->tokens[parser->current]; }

void advance(Parser *parser) { parser->current++; }

void retreat(Parser *parser) { parser->current--; }

char *parseLoop(Parser *parser, FILE *file, char *valStr, int topLevel);

void generateAssemblyHeader(FILE *file) {
  fprintf(file, "# Generated by nux %s\n", VERSION);
  fprintf(file, "# Starting the internal section\n");
  fprintf(file, ".section .renderlabs\n");
  fprintf(file, "    nux: .byte 1\n");
  fprintf(file, ".section .note.GNU-stack\n");
  fprintf(file, ".macro scall a, b, msg, len\n");
  fprintf(file, "    mov \\len, %%edx\n");
  fprintf(file, "    lea \\msg, %%rsi\n");
  fprintf(file, "    mov \\a, %%edi\n");
  fprintf(file, "    mov \\b, %%rax\n");
  fprintf(file, "    syscall\n");
  fprintf(file, ".endm\n");
  fprintf(file, ".section .text\n");
  fprintf(file, ".global _strlen\n");
  fprintf(file, "_strlen:\n");
  fprintf(file, "    push %%rbp\n");
  fprintf(file, "    mov %%rsp, %%rbp\n");
  fprintf(file, "    mov 16(%%rbp), %%rdi\n");
  fprintf(file, "    xor %%rax, %%rax\n");
  fprintf(file, ".L_strlen_loop:\n");
  fprintf(file, "    cmpb $0, (%%rdi, %%rax, 1)\n");
  fprintf(file, "    je .L_strlen_end\n");
  fprintf(file, "    inc %%rax\n");
  fprintf(file, "    jmp .L_strlen_loop\n");
  fprintf(file, ".L_strlen_end:\n");
  fprintf(file, "    mov %%rax, _len(%%rip)\n");
  fprintf(file, "    pop %%rbp\n");
  fprintf(file, "    ret\n");

  fprintf(file, ".global print\n");
  fprintf(file, "print:\n");
  fprintf(file, "    push %%rbp\n");
  fprintf(file, "    mov %%rsp, %%rbp\n");
  fprintf(file, "    mov 16(%%rbp), %%rdi\n");
  fprintf(file, "    mov %%rdi, _str(%%rip)\n");
  fprintf(file, "    call _strlen\n");
  fprintf(file, "    scall $1, $1, _str(%%rip), _len(%%rip)\n");
  fprintf(file, "    mov %%rbp, %%rsp\n");
  fprintf(file, "    pop %%rbp\n");
  fprintf(file, "    ret\n");

  fprintf(file, ".section .data\n");
  fprintf(file, "    _str: .asciz \"\"\n");
  fprintf(file, "    _len: .long 0\n");

  fprintf(file, "# Ending the internal variables\n");
  fprintf(file, "# Starting the crate section\n");
  if (1) {
    fprintf(file, "# No crates yet.\n");
  }

  fprintf(file, "# Ending the crate section\n");
  fprintf(file, ".section .text\n");
}

void generateAssemblyFooter(FILE *file, char *varStr) {
  fprintf(file, "# Starting the variable section\n");
  fprintf(file, ".section .data\n");
  fprintf(file, "%s\n", varStr);
  fprintf(file, "# Ending the variable section\n");
  fprintf(file, "# End of file\n");
  fprintf(file, "# *\n");
  fprintf(file, "# * Thank You.\n");
  fprintf(file, "# *\n");
}

char *getLeftSide(const char *input) {
  const char *spacePtr = strchr(input, ' ');

  if (spacePtr != NULL) {
    size_t length = spacePtr - input;

    char *leftSide = (char *)malloc(length + 1);
    if (leftSide != NULL) {
      strncpy(leftSide, input, length);
      leftSide[length] = '\0';

      return leftSide;
    }
  } else {
    return strdup(input);
  }

  return NULL;
}

char *getRightSide(const char *input) {
  const char *spacePtr = strchr(input, ' ');

  if (spacePtr != NULL) {
    size_t length = strlen(spacePtr + 1);

    char *rightSide = (char *)malloc(length + 1);
    if (rightSide != NULL) {
      strcpy(rightSide, spacePtr + 1);

      return rightSide;
    }
  }

  return NULL;
}

char *getType(Token typeName, char **type, char **value) {
  *type = "unknown";
  *value = "0";
  char *typeStr = "unknown";
  char *valueStr = "0";
  if (typeName.value == NULL) {
    typeStr = "byte";
    valueStr = "0";
  } else if (strcmp(typeName.value, "int") == 0) {
    typeStr = "long";
    valueStr = "0";
  } else if (strcmp(typeName.value, "char") == 0) {
    typeStr = "asciz";
    valueStr = "\"\"";
  }
  *type = typeStr;
  *value = valueStr;
  char *outputStr = (char *)malloc(strlen(typeStr) + strlen(valueStr) + 1);
  ;
  sprintf(outputStr, "%s %s", typeStr, valueStr);
  return outputStr;
}

Token createNilToken(char *value) {
  Token *token = (Token *)malloc(sizeof(Token));
  token->type = TOKEN_UNKNOWN;
  token->value = value;
  return *token;
}

void trim(char *str) {
  int len = strlen(str);
  int i = 0;
  while (len > 0 && (str[len - 1] == ' ' || str[len - 1] == '\n')) {
    len--;
  }
  str[len] = '\0';
  while (i < len && (str[len - 1] == ' ' || str[len - 1] == '\n')) {
    str[len - 1] = '\0';
    i++;
  }
}

char **getParameters(Parser *parser) {
  char **parameters = malloc(100 * sizeof(char *));
  int parameterCount = 0;
  int i = 0;

  while (currentToken(parser).value[i] != '\0' && parameterCount < 100) {
    int j = 0;
    char *buffer = malloc(100 * sizeof(char));

    if (currentToken(parser).value[i] == ' ') {
      i++;
      continue; // Skip spaces
    }

    while (currentToken(parser).value[i] != ',' &&
           currentToken(parser).value[i] != '\0') {
      buffer[j] = currentToken(parser).value[i];
      i++;
      j++;
    }
    buffer[j] = '\0';

    parameters[parameterCount] = strdup(buffer);
    parameterCount++;

    if (currentToken(parser).value[i] == ',') {
      i++;
    }
    free(buffer); // Avoid memory leak
  }

  return parameters;
}

void generateExpressionAssembly(FILE *file, Token *tokens, int tokenCount,
                                const char *varName, char *varStr,
                                char *assigningString) {
  int useEbx = 0; // Flag to track if %ebx is actively used

  for (int i = 0; i < tokenCount; ++i) {
    if (tokens[i].type == TOKEN_LITERAL) {
      fprintf(file, "    mov $%s, %%eax\n", tokens[i].value);
      if (!useEbx) {
        fprintf(file, "    mov %%eax, %%ebx\n");
        useEbx = 1;
      }
    } else if (tokens[i].type == TOKEN_IDENTIFIER) {
      fprintf(file, "    mov %s, %%eax\n", tokens[i].value);
      if (!useEbx) {
        fprintf(file, "    mov %%eax, %%ebx\n");
        useEbx = 1;
      }
    } else if (tokens[i].type == TOKEN_NUMBER) {
      fprintf(file, "    mov $%s, %%eax\n", tokens[i].value);
      if (!useEbx) {
        fprintf(file, "    mov %%eax, %%ebx\n");
        useEbx = 1;
      }
    } else if (tokens[i].type == TOKEN_STRING) {
      char tempName[12];
      int randomNum = rand() % 100;
      sprintf(tempName, "temp_%d", randomNum);
      sprintf(varStr, "%s: .asciz \"%s\"%s", tempName, tokens[i].value,
              assigningString);
      fprintf(file, "    mov %s(%%rip), %%eax\n", tempName);
    } else if (tokens[i].type == TOKEN_OPERATOR) {
      // Make sure there is a following token for the operand
      if (i + 1 < tokenCount && (tokens[i + 1].type == TOKEN_LITERAL ||
                                 tokens[i + 1].type == TOKEN_IDENTIFIER ||
                                 tokens[i + 1].type == TOKEN_NUMBER)) {
        fprintf(file, "    mov $%s, %%eax\n", tokens[i + 1].value);
        if (!useEbx) {
          fprintf(file, "    mov %%eax, %%ebx\n");
          useEbx = 1;
        }

        // Process the operation based on the current operator
        if (strcmp(tokens[i].value, "+") == 0) {
          fprintf(file, "    add %%ebx, %%eax\n");
        } else if (strcmp(tokens[i].value, "-") == 0) {
          fprintf(file, "    sub %%ebx, %%eax\n");
        } else if (strcmp(tokens[i].value, "*") == 0) {
          fprintf(file, "    imul %%ebx, %%eax\n");
        } else if (strcmp(tokens[i].value, "/") == 0) {
          fprintf(file, "    mov $0, %%edx\n");
          fprintf(file, "    idiv %%ebx\n");
        } else if (strcmp(tokens[i].value, "%") == 0) {
          fprintf(file, "    mov $0, %%edx\n");
          fprintf(file, "    idiv %%ebx\n");
          fprintf(file, "    mov %%edx, %%eax\n"); // Move remainder into %eax
        } else if (strcmp(tokens[i].value, ">") == 0) {
          fprintf(file, "    cmp %%ebx, %%eax\n");
          fprintf(file, "    setg %%al\n");
          fprintf(file, "    movzb %%al, %%eax\n"); // Zero-extend %al to %eax
        } else if (strcmp(tokens[i].value, "<") == 0) {
          fprintf(file, "    cmp %%ebx, %%eax\n");
          fprintf(file, "    set %%al\n");
          fprintf(file, "    movzb %%al, %%eax\n"); // Zero-extend %al to %eax
        } else if (strcmp(tokens[i].value, "~") == 0) {
          fprintf(file, "    cmp %%ebx, %%eax\n");
          fprintf(file, "    sete %%al\n");
          fprintf(file, "    movzb %%al, %%eax\n"); // Zero-extend %al to %eax
        } else if (strcmp(tokens[i].value, "!~") == 0) {
          fprintf(file, "    cmp %%ebx, %%eax\n");
          fprintf(file, "    setne %%al\n");
          fprintf(file, "    movzb %%al, %%eax\n"); // Zero-extend %al to %eax
        } else if (strcmp(tokens[i].value, "!") == 0) {
        }

        // Skip the next token since it's already processed
        i++;
      } else {
        // Error: Operator without a following operand
        fprintf(stderr, "Error: Operator '%s' without a following operand.\n",
                tokens[i].value);
      }
    } else if (tokens[i].type == TOKEN_PUNCTUATION) {
      if (strcmp(tokens[i].value, "(") == 0) {
        fprintf(file, "    push %%ebx\n");
      } else if (strcmp(tokens[i].value, ")") == 0) {
        fprintf(file, "    popl %%ebx\n");
      }
    }
  }

  // Store the final result in 'varName'
  fprintf(file, "    mov %%eax, %s(%%rip)\n", varName);
}

void generateFunctionAssembly(FILE *file, Token funcName, char **parameterNames,
                              char **parameterTypes, char *body, char *varStr) {
  fprintf(file, ".global %s\n", funcName.value);
  fprintf(file, "%s:\n", funcName.value);
  int i = 0;
  int parameterCount = 0;

  while (parameterNames[i] != NULL && parameterCount < 100) {
    sprintf(varStr, "%s: .%s\n", parameterNames[i],
            getType(createNilToken(parameterTypes[i]), &nptr, &nptr));
    i++;
    parameterCount++;
  }
  fprintf(file, "    push %%rbp\n");
  fprintf(file, "    mov %%rsp, %%rbp\n");
  fprintf(file, "    sub $16, %%rsp\n");

  for (i = 0; i < parameterCount; i++) {
    fprintf(file,
            "    pop %%rax\n"); // Pop the parameter from the stack into %rax
    fprintf(file, "    mov %%rax, %s(%%rip)\n", parameterNames[i]);
  }
  fprintf(file, "    # Function body\n");

  Token *tokens = tokenize(body);
  Parser parser = {tokens, 0};
  parseLoop(&parser, file, varStr, 0);
  if (strcmp(funcName.value, "main") == 0) {
  }
}

void generateObjectAssembly(FILE *file, Token objectName) {
  fprintf(file, "# Object %s\n", objectName.value);
}

void generateVarAssembly(FILE *file, Token varName, Token typeName,
                         char *varStr) {
  char *type = "";
  char *value = "";
  getType(typeName, &type, &value);
  sprintf(varStr, "%s: .%s %s\n", varName.value, type, value);
}

void generateFunctionCallAssembly(FILE *file, char **parameters,
                                  const char *varName) {
  int i = 0;
  while (parameters[i] != NULL) {
    fprintf(file, "    mov %s(%%rip), %%rsi\n", &*parameters[i]);
    fprintf(file, "    push %%rsi\n");
    i++;
  }
  fprintf(file, "    call %s\n", varName);
}

void generateDebugAssembly(FILE *file, Token debugPoint) {
  char tempName[17];
  int randomNum = rand() % 100;
  sprintf(tempName, "debug_temp_%d", randomNum);
  fprintf(file, "# Debug point\n");
  // fprintf(file, "    %s: .asciz \"%s\"\n", tempName, debugPoint.value);
  fprintf(file, "    mov %s, %%eax\n", tempName);
}

void generateReturnAssembly(FILE *file, Token returnValue) {
  if (returnValue.type == TOKEN_IDENTIFIER) {
    fprintf(file, "    mov %s(%%rip), %%eax\n", returnValue.value);
  } else {
    fprintf(file, "    mov $%s, %%eax\n", returnValue.value);
  }
  fprintf(file, "    mov %%rbp, %%rsp\n");
  fprintf(file, "    pop %%rbp\n"); // Clear local variables
  fprintf(file, "    ret\n");
}

void generateIfAssembly(FILE *file, Token body) {}

void parseExpression(Parser *parser, FILE *file, const char *varName,
                     char *varStr) {
  Token tokens[BUFFER_SIZE];
  int tokenCount = 0;
  char assigningString[BUFFER_SIZE];
  retreat(parser);
  retreat(parser);
  retreat(parser);
  retreat(parser);

  advance(parser);
  advance(parser);
  advance(parser);
  advance(parser);

  while (currentToken(parser).type != TOKEN_EOL) {
    tokens[tokenCount++] = currentToken(parser);
    advance(parser);
  }
  advance(parser); // Check for function call
  if (currentToken(parser).type == TOKEN_PARENTHISES) {
    char **parameters = getParameters(parser);
    generateFunctionCallAssembly(file, parameters, varName);
  } else {
    retreat(parser);
  }

  generateExpressionAssembly(file, tokens, tokenCount, varName, varStr,
                             assigningString);
}

void parseFunction(Parser *parser, FILE *file, char *varStr) {
  advance(parser); // Skip 'func'

  Token funcName = currentToken(parser);
  if (funcName.type != TOKEN_IDENTIFIER) {
    fprintf(stderr, "Expected function name, but got %s\n", funcName.value);
    return;
  }

  advance(parser); // Skip function name
  char **parameters = getParameters(parser);
  char **parameterNames = malloc(BUFFER_SIZE * sizeof(char *));
  char **parameterTypes = malloc(BUFFER_SIZE * sizeof(char *));
  int i = 0;
  while (parameters[i] != NULL) {
    parameterNames[i] = getRightSide(parameters[i]);
    parameterTypes[i] = getLeftSide(parameters[i]);
    i++;
  }

  advance(parser); // Skip '[...]'
  char *body = currentToken(parser).value;
  advance(parser); // Skip '#{'

  generateFunctionAssembly(file, funcName, parameterNames, parameterTypes, body,
                           varStr);
  advance(parser); // Skip '}'
}

void parseObject(Parser *parser, FILE *file, char *varStr) {
  advance(parser); // Skip 'object'
  Token objectName = currentToken(parser);
  advance(parser); // Skip object name
  advance(parser); // Skip '{'

  printf("Parsing object: %s\n", objectName.value);
  generateObjectAssembly(file, objectName);

  while (strcmp(currentToken(parser).value, "}") != 0) {
    if (currentToken(parser).type == TOKEN_FUNCTION) {
      parseFunction(parser, file, varStr);
    } else {
      advance(parser);
    }
  }
  advance(parser); // Skip '}'
}

void parseLet(Parser *parser, FILE *file, char *varStr) {
  advance(parser); // Skip 'let'
  Token typeName = currentToken(parser);

  advance(parser);

  Token varName = currentToken(parser);
  advance(parser); // Skip var name
  generateVarAssembly(file, varName, typeName, varStr);
}

void parseSet(Parser *parser, FILE *file, char *varStr) {
  retreat(parser);
  Token varName = currentToken(parser);
  advance(parser); // Skip variable name

  if (currentToken(parser).type != TOKEN_SET) {
    fprintf(stderr, "Expected '=', but got %s\n", currentToken(parser).value);
    return;
  }
  advance(parser); // Skip '='

  parseExpression(parser, file, varName.value, varStr);
}

void parseIdentifier(Parser *parser, FILE *file) {
  Token identifier = currentToken(parser);
  advance(parser); // Skip identifier
  if (currentToken(parser).type == TOKEN_PARENTHISES) {
    char **parameters = getParameters(parser);
    generateFunctionCallAssembly(file, parameters, identifier.value);
    advance(parser); // Skip ')'
  }
}

void parseDebug(Parser *parser, FILE *file) {
  advance(parser); // Skip debug
  Token debugPoint = currentToken(parser);
  if (currentToken(parser).type == TOKEN_NUMBER) {
    generateDebugAssembly(file, debugPoint);
  }
}

void parseReturn(Parser *parser, FILE *file) {
  advance(parser); // Skip return
  Token returnValue = currentToken(parser);
  if (returnValue.type == TOKEN_NUMBER ||
      returnValue.type == TOKEN_IDENTIFIER) {
    generateReturnAssembly(file, returnValue);
    advance(parser); // Skip return value
  }
}

char *parseLoop(Parser *parser, FILE *file, char *varStr, int topLevel) {
  const char *varNames[] = {

  };
  int varNamesCount = 0;
  char footer[BUFFER_SIZE * FOOTER_MULTIPLIER] = "";

  while (currentToken(parser).type != TOKEN_EOF) {
    switch (currentToken(parser).type) {
    case TOKEN_FUNCTION:
      parseFunction(parser, file, varStr);
      break;
    case TOKEN_LET:
      parseLet(parser, file, varStr);
      break;
    case TOKEN_OBJECT:
      parseObject(parser, file, varStr);
      break;
    case TOKEN_TYPE:
      advance(parser); // Skip 'type'
      Token typeName = currentToken(parser);
      advance(parser); // Skip type name
      advance(parser); // Skip '{'

      printf("Parsing type: %s\n", typeName.value);
      // Implement type parsing and generation
      break;
    case TOKEN_SET:
      parseSet(parser, file, varStr);
      advance(parser);
      break;
    case TOKEN_IDENTIFIER:
      parseIdentifier(parser, file);
      break;
    case TOKEN_DEBUG:
      parseDebug(parser, file);
      break;
    case TOKEN_RETURN:
      parseReturn(parser, file);
      break;
    case TOKEN_EOL:
      advance(parser);
      break;
    default:
      fprintf(stderr, "Error: Unexpected token type %d\n",
              currentToken(parser).type);
      fprintf(stderr, "Error: Unexpected token value %s\n",
              currentToken(parser).value);
      advance(parser);
      break;
    }
    int i = 0;
    int valid = 1;
    trim(varStr); // Assuming this function trims spaces and newlines
    strcat(varStr, "\n");

    while (i < varNamesCount) {
      if (strcmp(varStr, varNames[i]) == 0) {
        valid = 0;
        break;
      } else
        i++;
    }

    if (valid == 1) {
      varNames[varNamesCount] = strdup(varStr); // Copy the string
      varNamesCount++;
      i++;

      strcat(footer, varStr); // Append to footer
      strcpy(varStr, "");     // Clear varStr
    }
  }
  strcpy(varStr, footer);
  return footer;
}

void parse(Parser *parser, const char *outputFileName) {
  FILE *file = fopen(outputFileName, "w");
  char varStr[BUFFER_SIZE];
  if (!file) {
    fprintf(stderr, "Error: Could not open output file %s\n", outputFileName);
    exit(1);
  }
  printf("Parsing...\n");
  generateAssemblyHeader(file);
  char *footer = parseLoop(parser, file, varStr, 1);
  generateAssemblyFooter(file, footer);

  fclose(file);
}
