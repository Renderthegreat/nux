/*
 * Please read the main.c file for license.
 */

#include "parser.h"
#include "lexer.h"
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TOKEN_LENGTH 100

Token currentToken(Parser *parser) { return parser->tokens[parser->current]; }

void advance(Parser *parser) { parser->current++; }

void retreat(Parser *parser) { parser->current--; }

void parseLoop(Parser *parser, FILE *file);

void generateAssemblyHeader(FILE *file) { fprintf(file, "# Generated by nux"); }

void generateExpressionAssembly(FILE *file, Token *tokens, int tokenCount,
                                const char *varName) {
  fprintf(file, ".section .text\n");
  int useEbx = 0; // Flag to track if %ebx is actively used

  for (int i = 0; i < tokenCount; ++i) {
    if (tokens[i].type == TOKEN_LITERAL) {
      fprintf(file, "    movl $%s, %%eax\n", tokens[i].value);
      if (!useEbx) {
        fprintf(file, "    movl %%eax, %%ebx\n");
        useEbx = 1;
      }
    } else if (tokens[i].type == TOKEN_IDENTIFIER) {
      fprintf(file, "    movl %s, %%eax\n", tokens[i].value);
      if (!useEbx) {
        fprintf(file, "    movl %%eax, %%ebx\n");
        useEbx = 1;
      }
    } else if (tokens[i].type == TOKEN_NUMBER) {
      fprintf(file, "    movl $%s, %%eax\n", tokens[i].value);
      if (!useEbx) {
        fprintf(file, "    movl %%eax, %%ebx\n");
        useEbx = 1;
      }
    } else if (tokens[i].type == TOKEN_STRING) {
      char tempName[12];
      int randomNum = rand() % 100;
      sprintf(tempName, "temp_%d", randomNum);
       fprintf(file, "    .section .data\n");
      fprintf(file, "%s: .asciz \"%s\"\n", tempName, tokens[i].value);
       fprintf(file, "    .section .text\n");
      fprintf(file, "    movl $%s, %%eax\n", tempName);
    } else if (tokens[i].type == TOKEN_OPERATOR) {
      // Make sure there is a following token for the operand
      if (i + 1 < tokenCount && (tokens[i + 1].type == TOKEN_LITERAL ||
                                 tokens[i + 1].type == TOKEN_IDENTIFIER ||
                                 tokens[i + 1].type == TOKEN_NUMBER)) {
        fprintf(file, "    movl $%s, %%eax\n", tokens[i + 1].value);
        if (!useEbx) {
          fprintf(file, "    movl %%eax, %%ebx\n");
          useEbx = 1;
        }

        // Process the operation based on the current operator
        if (strcmp(tokens[i].value, "+") == 0) {
          fprintf(file, "    addl %%ebx, %%eax\n");
        } else if (strcmp(tokens[i].value, "-") == 0) {
          fprintf(file, "    subl %%ebx, %%eax\n");
        } else if (strcmp(tokens[i].value, "*") == 0) {
          fprintf(file, "    imull %%ebx, %%eax\n");
        } else if (strcmp(tokens[i].value, "/") == 0) {
          fprintf(file, "    movl $0, %%edx\n");
          fprintf(file, "    idivl %%ebx\n");
        } else if (strcmp(tokens[i].value, "%") == 0) {
          fprintf(file, "    movl $0, %%edx\n");
          fprintf(file, "    idivl %%ebx\n");
          fprintf(file, "    movl %%edx, %%eax\n"); // Move remainder into %eax
        }

        // Skip the next token since it's already processed
        i++;
      } else {
        // Error: Operator without a following operand
        fprintf(stderr, "Error: Operator '%s' without a following operand.\n",
                tokens[i].value);
      }
    } else if (tokens[i].type == TOKEN_PUNCTUATION) {
      if (strcmp(tokens[i].value, "(") == 0) {
        fprintf(file, "    pushl %%ebx\n");
      } else if (strcmp(tokens[i].value, ")") == 0) {
        fprintf(file, "    popl %%ebx\n");
      }
    }
  }

  // Store the final result in 'varName'
  fprintf(file, "    movl %%eax, %s\n", varName);
}

void generateFunctionAssembly(FILE *file, Token funcName, char *parameters,
                              char *body) {
  fprintf(file, ".global %s\n", funcName.value);
  fprintf(file, "%s:\n", funcName.value);
  Token *tokens = tokenize(body);
  Parser parser = {tokens, 0};
  parseLoop(&parser, file);
  fprintf(file, "    ret #Final return on function %s\n", funcName.value);
}

void generateObjectAssembly(FILE *file, Token objectName) {
  fprintf(file, "# Object %s\n", objectName.value);
}

void generateVarAssembly(FILE *file, Token varName, Token typeName) {
  char *type = "";
  char *value = "";
  if (typeName.value == NULL) {
    type = "byte";
    value = "0";
  } else if (strcmp(typeName.value, "int") == 0) {
    type = "long";
    value = "0";
  } else if (strcmp(typeName.value, "string") == 0) {
    type = "asciz";
    value = "\"\"";
  }
  fprintf(file, ".section .data\n");
  fprintf(file, "%s: .%s %s\n", varName.value, type, value);
}

void generateFunctionCallAssembly(FILE *file, Token funcCall,
                                  const char *varName) {
  int length = 0;
  int paramCount = 0;
  char *parameters = (char *)malloc(sizeof(char) * 100);
  while (funcCall.value[length] != '\0') {
    while (funcCall.value[length] != '\0' && funcCall.value[length] != ',') {
      parameters[length] = funcCall.value[length];
      length++;
    }
    paramCount++;
  }
  parameters[length] = '\0';
  for (int i = 0; i < paramCount; i++) {
    fprintf(file, "    push %s\n", parameters);
  }
  fprintf(file, "    call %s\n", varName);
}

void generateDebugAssembly(FILE *file, Token debugPoint) {
  char tempName[17];
  int randomNum = rand() % 100;
  sprintf(tempName, "debug_temp_%d", randomNum);
  fprintf(file, "# Debug point\n");
  fprintf(file, ".section .data\n");
  fprintf(file, "    %s: .asciz \"%s\"\n", tempName, debugPoint.value);
  fprintf(file, ".section .text\n");
  fprintf(file, "    mov %s, %%eax\n", tempName);
}

void generateReturnAssembly(FILE *file, Token returnValue) {
  fprintf(file, "    movl $%s, %%eax", returnValue.value);
  fprintf(file, "    ret\n");
}

void parseExpression(Parser *parser, FILE *file, const char *varName) {
  Token tokens[100];
  int tokenCount = 0;

  while (currentToken(parser).type != TOKEN_EOL) {
    tokens[tokenCount++] = currentToken(parser);
    advance(parser);
  }
  advance(parser); // Check for function call
  if (currentToken(parser).type == TOKEN_PARENTHISES) {
    generateFunctionCallAssembly(file, currentToken(parser), varName);
  } else {
    retreat(parser);
  }

  generateExpressionAssembly(file, tokens, tokenCount, varName);
}

void parseFunction(Parser *parser, FILE *file) {
  advance(parser); // Skip 'func'

  Token funcName = currentToken(parser);
  char *parameters[100];
  int parameterCount = 0;
  if (funcName.type != TOKEN_IDENTIFIER) {
    fprintf(stderr, "Expected function name, but got %s\n", funcName.value);
    return;
  }

  advance(parser); // Skip function name

  int i = 0;
  while (currentToken(parser).value[i] != '\0') {
    int j = 0;
    char *buffer = (char *)malloc(sizeof(char) * MAX_TOKEN_LENGTH);
    while (currentToken(parser).value[j] != ',' &&
           currentToken(parser).value[j] != '\0') {
      buffer[j] = currentToken(parser).value[j];
      j++;
    }
    parameters[parameterCount] = buffer;
    i++;
  }
  advance(parser); // Skip '[...]'
  char *body = currentToken(parser).value;
  advance(parser); // Skip '#{'

  generateFunctionAssembly(file, funcName, parameters, body);
  advance(parser); // Skip '}'
}

void parseObject(Parser *parser, FILE *file) {
  advance(parser); // Skip 'object'
  Token objectName = currentToken(parser);
  advance(parser); // Skip object name
  advance(parser); // Skip '{'

  printf("Parsing object: %s\n", objectName.value);
  generateObjectAssembly(file, objectName);

  while (strcmp(currentToken(parser).value, "}") != 0) {
    if (currentToken(parser).type == TOKEN_FUNCTION) {
      parseFunction(parser, file);
    } else {
      advance(parser);
    }
  }
  advance(parser); // Skip '}'
}

void parseLet(Parser *parser, FILE *file) {
  advance(parser); // Skip 'let'
  Token typeName = currentToken(parser);

  advance(parser);

  Token varName = currentToken(parser);
  advance(parser); // Skip var name
  generateVarAssembly(file, varName, typeName);
}

void parseSet(Parser *parser, FILE *file) {
  retreat(parser);
  Token varName = currentToken(parser);
  advance(parser); // Skip variable name

  if (currentToken(parser).type != TOKEN_SET) {
    fprintf(stderr, "Expected '=', but got %s\n", currentToken(parser).value);
    return;
  }
  advance(parser); // Skip '='

  parseExpression(parser, file, varName.value);
}

void parseIdentifier(Parser *parser, FILE *file) {
  Token identifier = currentToken(parser);
  advance(parser); // Skip identifier
  if (currentToken(parser).type == TOKEN_PARENTHISES) {
    generateFunctionCallAssembly(file, currentToken(parser), identifier.value);
    advance(parser); // Skip ')'
  }
}

void parseDebug(Parser *parser, FILE *file) {
  advance(parser); // Skip debug
  Token debugPoint = currentToken(parser);
  if (currentToken(parser).type == TOKEN_NUMBER) {
    generateDebugAssembly(file, debugPoint);
  }
}

void parseReturn(Parser *parser, FILE *file) {
  advance(parser); // Skip return
  Token returnValue = currentToken(parser);
  if (currentToken(parser).type == TOKEN_NUMBER) {
    generateReturnAssembly(file, returnValue);
  }
}

void parseLoop(Parser *parser, FILE *file) {
  while (currentToken(parser).type != TOKEN_EOF) {
    switch (currentToken(parser).type) {
    case TOKEN_FUNCTION:
      parseFunction(parser, file);
      break;
    case TOKEN_LET:
      parseLet(parser, file);
      break;
    case TOKEN_OBJECT:
      parseObject(parser, file);
      break;
    case TOKEN_TYPE:
      advance(parser); // Skip 'type'
      Token typeName = currentToken(parser);
      advance(parser); // Skip type name
      advance(parser); // Skip '{'

      printf("Parsing type: %s\n", typeName.value);
      // Implement type parsing and generation
      break;
    case TOKEN_SET:
      parseSet(parser, file);
      advance(parser);
      break;
    case TOKEN_IDENTIFIER:
      parseIdentifier(parser, file);
      break;
    case TOKEN_DEBUG:
      parseDebug(parser, file);
      break;
    case TOKEN_EOL:
      advance(parser);
      break;
    default:
      fprintf(stderr, "Error: Unexpected token type %d\n",
              currentToken(parser).type);
      fprintf(stderr, "Error: Unexpected token value %s\n",
              currentToken(parser).value);
      advance(parser);
      break;
    }
  }
}

void parse(Parser *parser, const char *outputFileName) {
  FILE *file = fopen(outputFileName, "w");
  if (!file) {
    fprintf(stderr, "Error: Could not open output file %s\n", outputFileName);
    exit(1);
  }
  printf("Parsing...\n");
  parseLoop(parser, file);

  fclose(file);
}
